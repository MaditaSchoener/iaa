package de.nordakademie.iaa.model.repository;import java.time.LocalDate;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.persistence.TypedQuery;import org.springframework.stereotype.Repository;import de.nordakademie.iaa.model.Member;import de.nordakademie.iaa.model.Membership;/** * Repository der Mitglieder. Beinhaltet normale create, update und find Methoden, sowie validate. * * Beinhaltet zusätzlich eine Klasse SearchCriteria, welche durch Methodenaufrufe aus dem Frontent einen Suchstring * zusammensetzt, um Mitgliedereintrage zu finden. * * @author Maik Voigt */@Repositorypublic class MemberRepository extends AbstractRepository <Member> implements IMemberRepository {		private static final String MEMBER_VAR_NAME = " m";	private static final String SELECT_CLAUSE = "SELECT" + MEMBER_VAR_NAME + " FROM Member" + MEMBER_VAR_NAME;		public MemberRepository() {		super(Member.class);	}	/**	 * Erstellt ein neues Mitglied	 *	 * @param member Mitgliedsobjekt vom Typ Member	 * @return Gibt das Mitglied mit ID zurück	 * @throws IllegalEntityException Exception falls Mitglied ungültig ist	 */	@Override	public Member create(Member member) throws IllegalEntityException {		validate(member);		return super.persist(member);	}	/**	 * Aktualisiert ein Mitglied	 *	 * @param type Mitgliedsobjekt vom Typ Member	 * @return Gibt das Mitglied mit ID zurück	 * @throws IllegalEntityException Exception falls Mitglied ungültig ist	 */	@Override	public Member update(Member type) throws IllegalEntityException {		validate(type);		return super.update(type);	}	/**	 * Sucht alle zugehörigen Mitglieder	 * @return Gibt die Ergbenisliste zurück	 */	@Override	public List<Member> findAll() {		return entityManager().createQuery(SELECT_CLAUSE, Member.class).getResultList();	}	@Override	public Member find(Long id) {		return super.find(id);	}	/**	 * Erstellt eine Suchabfrage aus den übergebenen Suchkriterien	 * @param criteria übergebene Suchkriterien	 * @return Gibt die Ergebnisliste zurück	 */	@Override	public List<Member> search(SearchCriteria criteria) {		if (criteria.hasSearchCriteria()) {			StringBuilder queryString = new StringBuilder(SELECT_CLAUSE);			queryString.append(" WHERE");			queryString.append(criteria.getJPLString());			TypedQuery<Member> query = entityManager().createQuery(queryString.toString(), Member.class);			criteria.getQueryVarsToSet().forEach((name, value) -> query.setParameter(name, value));			return query.getResultList();		} else {			return findAll();		}		}	/**	 * Validiert das Mitgliedsobjekt	 * @param member Mitgliedsobjekt vom Typ Member	 * @throws IllegalEntityException Exception, falls die Validierung fehlgeschlagen ist und die	 * Nachrichtenliste nicht leer ist.	 */	private void validate (Member member) throws IllegalEntityException {		List <String> messages = new ArrayList<>();		if (member.getType() == null) {			messages.add("Es muss eine Mitgliedschaftsart ausgewählt sein!");		}		if (member.getName() == null || member.getName().trim().isEmpty()			|| member.getSurname() == null || member.getSurname().trim().isEmpty()) {			messages.add("Mitglieder müssen mit Vor-und Nachnamen eingetragen werden!");		}		if (member.getBirth() == null || member.getBirth().isAfter(LocalDate.now())) {			messages.add("Der Geburtstag eines Mitglieds darf nicht in der Zukunft liegen.");		}		if (!messages.isEmpty()) {			throw new IllegalEntityException(messages);		}	}	/**	 * Erstellt ein Suchkriterienobjekt aus den aufgerufenen Suchmethoden	 */	public static class SearchCriteria {		private final StringBuilder searchCriteriaConcatinator = new StringBuilder();		private final Map <String, Object> queryVarsToSet = new HashMap<>();		/**		 * Fügt das Suchkriterum Mitgliedstyp hinzu		 * @param membership Mitgliedstyp vom Typ Membership		 * @return Gibt die Suchanfrage als String zurück		 */		public SearchCriteria appendType(Membership membership) {			queryVarsToSet.put("type", membership);			return appendCriteria("type", ":type");		}		/**		 * Fügt das Suchkriterium Straße hinzu		 * @param street Straße als String		 * @return Gibt die Suchanfrage als String zurück		 */		public SearchCriteria appendStreet(String street) {			return appendCriteria("address.identification.street", markStringAsString(street));		}		/**		 * Fügt das Suchkriterium PLZ hinzu		 * @param zip PLZ vom Typ Integer		 * @return Gibt die Suchanfrage als String zurück		 */		public SearchCriteria appendZip(int zip) {			return appendCriteria("address.identification.zip", zip);		}		/**		 * Fügt das Suchkriterium Name hinzu		 * @param name Name als String		 * @return Gibt die Suchanfrage als String zurück		 */		public SearchCriteria appendName(String name) {			return appendCriteria("name", markStringAsString(name));		}		/**		 * Fügt das Suchkriterium Nachname hinzu		 * @param surname Nachname als String		 * @return Gibt die Suchanfrage als String zurück		 */		public SearchCriteria appendSurname(String surname) {			return appendCriteria("surname", markStringAsString(surname));		}		/**		 * Fügt das Suchkriterium der gesamten Suchabfrage an		 * @param propertyName Name der Eigenschaft als String		 * @param value Wert der Eigenschaft als Object		 * @return Gibt die Suchanfrage als String zurück		 */		private SearchCriteria appendCriteria (String propertyName, Object value) {			if (hasSearchCriteria()) {				searchCriteriaConcatinator.append(" AND ");			}			searchCriteriaConcatinator.append(MEMBER_VAR_NAME);			searchCriteriaConcatinator.append(".");			searchCriteriaConcatinator.append(propertyName);			searchCriteriaConcatinator.append(" = ");			searchCriteriaConcatinator.append(value);			return this;		}		/**		 * Maskiert Stringwerte mit den Stringzeichen		 * @param string Stringwert als String		 * @return Stringwert in Stringzeichen		 */		private String markStringAsString (String string) {			return "'" + string + "'";		}		/**		 * Gibt zurück, ob Suchkriterien existieren		 * @return GIbt zurück ob Suchkriterien existieren als Boolean		 */		public boolean hasSearchCriteria () {			return searchCriteriaConcatinator.length() > 0;		}		/**		 * Erstellt den JPL String		 * @return JPLString als String		 */		protected String getJPLString () {			return searchCriteriaConcatinator.toString();		}		protected Map <String, Object> getQueryVarsToSet () {			return queryVarsToSet;		}	}}